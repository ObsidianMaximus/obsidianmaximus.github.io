<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
	<title>My website.</title>
	<link>/tags/extraction/</link>
	<description>Recent content in extraction on My website.</description>
	<generator>Hugo -- gohugo.io</generator>
	<language>en-us</language>
	<lastBuildDate>Wed, 24 Apr 2024 21:53:31 +0530</lastBuildDate>
    
        <atom:link href="/tags/extraction/index.xml" rel="self" type="application/rss+xml" />
	
	
	<item>
		<title>Use SSH or Rsync With Android</title>
		<link>/blog/use-ssh-or-rsync-with-android/</link>
		<pubDate>Fri, 26 Apr 2024 09:28:58 +0530</pubDate>
		
		<guid>/blog/use-ssh-or-rsync-with-android/</guid>
		<description>&lt;p&gt;Today, i wanted to send a file from my desktop to my android device. I thought of using rsync for this purpose, which is a tool that i use frequently to sync files between my desktop and my laptop.&lt;/p&gt;
&lt;p&gt;I thought of giving it a try and came across &lt;a href=&#34;https://howtos.davidsebek.com/android-rsync-termux.html&#34;&gt;this great article&lt;/a&gt; that explained just this.&lt;/p&gt;
&lt;h3 id=&#34;note-this-guide-requires-both-the-computer-and-the-android-device-to-be-on-the-same-wifi-network&#34;&gt;NOTE: This guide requires both the computer and the Android device to be on the same wifi network.&lt;/h3&gt;
&lt;p&gt;The process to send files from PC to Android which i took was as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Install rsync on termux using the command: &lt;strong&gt;&lt;code&gt;apt install rsync&lt;/code&gt;&lt;/strong&gt; and install openssh using the command: &lt;strong&gt;&lt;code&gt;apt install openssh&lt;/code&gt;&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Then setup the internal storage of our Android device to be accessible by termux using the command: &lt;strong&gt;&lt;code&gt;termux-setup-storage&lt;/code&gt;&lt;/strong&gt;. Grant termux the permission to access storage when prompted.&lt;/li&gt;
&lt;li&gt;Now, change the sshd config file to allow termux to use SSH port. Termux does not have the permission to use the default SSH port 22, so we will use 60022 port instead. For doing this, edit the ../usr/etc/ssh/sshd_config file by simply using the command: &lt;strong&gt;&lt;code&gt;echo &amp;quot;Port 60022&amp;quot; &amp;gt;&amp;gt; ../usr/etc/ssh/sshd_config&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Let&amp;rsquo;s get the local ip address of our device by using the command: &lt;strong&gt;&lt;code&gt;ifconfig&lt;/code&gt;&lt;/strong&gt;. The ip address should be usually in the end and will be after &amp;ldquo;inet&amp;rdquo; . Or you can just go to Settings app and click on wifi and select the wifi you are connected to and look for the ipv4 address. In either of these 2 cases, the ip address should usually begin with &lt;strong&gt;192.168.xx.xx&lt;/strong&gt; where x&amp;rsquo;s are to be replaced by your ip address part.&lt;/li&gt;
&lt;li&gt;Setup a password for the user by using the command: &lt;strong&gt;&lt;code&gt;passwd&lt;/code&gt;&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Finally, we have to start the SSH daemon. To do this, enter this in termux: &lt;strong&gt;&lt;code&gt;sshd -D&lt;/code&gt;&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;for-using-ssh-&#34;&gt;For using SSH :&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Open terminal on your pc and type: &lt;strong&gt;&lt;code&gt;ssh -p 60022 192.168.xx.xx&lt;/code&gt;&lt;/strong&gt; [where the x&amp;rsquo;s are replaced by your ipv4 address part].&lt;/li&gt;
&lt;li&gt;You should now be able to use android terminal through your desktop terminal.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;for-using-rsync-&#34;&gt;For using Rsync :&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Simply enter the command : &lt;strong&gt;&lt;code&gt;rsync -e &#39;ssh -p 60022&#39; &amp;lt;file to transfer from pc&amp;gt; 192.168.xx.xx:/storage/emulated/0/&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Explanation of some stuff in the above commands :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The -e command is used to specify the remote shell to use. For more details, check the manpage of rsync.&lt;/li&gt;
&lt;li&gt;The x&amp;rsquo;s replace your ipv4 address parts.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;storage/emulated/0/&lt;/strong&gt; is the &amp;ldquo;usual&amp;rdquo; path of the main storage in our Android which the user can access, so we are sending the file from our desktop to our Android device&amp;rsquo;s internal storage using this. You can specify some folder to send the file into directly by simply adding the folder after &lt;strong&gt;0/&lt;/strong&gt; in the command.&lt;/li&gt;
&lt;li&gt;This should work in vice-versa as well. Just add the path to copy from Android first and the path to copy to in your desktop after this.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4 id=&#34;side-note&#34;&gt;Side Note:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;To avoid entering password all the time while accessing SSH/Rsync, generate a key pair on your pc using the command: &lt;strong&gt;&lt;code&gt;ssh-keygen&lt;/code&gt;&lt;/strong&gt; and then copy it to Android using the command: &lt;strong&gt;&lt;code&gt;ssh-copy-id -p 60022 192.168.xx.xx&lt;/code&gt;&lt;/strong&gt; in your desktop terminal. This will ask you password only once and after authenticating it, you can now just use SSH/Rsync without entering that password which we generated in the &amp;ldquo;Step 5&amp;rdquo; in the beginning.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;REMEMBER&lt;/strong&gt; that the ip address of your android device can change from time to time due to ip addresses being dynamic when using wifi. Or they &amp;ldquo;may&amp;rdquo; change if the router is restarted. In any case, be sure to repeat the &amp;ldquo;Step 4&amp;rdquo; which we did in the beginning to find our local ip address.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
	</item>
	
	<item>
		<title>Ubuntu Touch Port Part 1</title>
		<link>/blog/ubuntutouchportpart1/</link>
		<pubDate>Thu, 25 Apr 2024 13:38:00 +0530</pubDate>
		
		<guid>/blog/ubuntutouchportpart1/</guid>
		<description>&lt;h1 id=&#34;getting-started&#34;&gt;Getting Started&lt;/h1&gt;
&lt;p&gt;So I recently decided to get more involved in the Android world and came about a &amp;lsquo;new&amp;rsquo; type of OS, known as Ubuntu Touch. I thought a bit on it and decided to start the porting process for it for my device Realme GT Neo 2 [codenamed:bitra].&lt;/p&gt;
&lt;p&gt;I started with the &lt;a href=&#34;https://docs.ubports.com/en/latest/porting/introduction/index.html&#34;&gt;official documentation of UBports&lt;/a&gt; where in they gave some good amount of introduction on how and why certain things needed to be done.&lt;/p&gt;
&lt;p&gt;The guide mentions the use of GSI for devices with Android 8+ and, as my device is indeed treble supported, I think I will head to using GSI only.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.ubports.com/en/latest/porting/build_and_boot/standalone_kernel_build.html&#34;&gt;Standalone Kernel Method (Halium 9 and newer)&lt;/a&gt; is very interesting as it seems to be the least tiresome way for porting among all of the 3 mentioned methods. So I started with this and did the steps as mentioned in the guide.&lt;/p&gt;
&lt;p&gt;The defconfig that i had to use is the &lt;a href=&#34;https://gitlab.com/Krishna-Yadav/android_kernel_realme_sm8250/-/blob/master/arch/arm64/configs/vendor/sm8250_defconfig?ref_type=heads&#34;&gt;sm8250_defconfig&lt;/a&gt;. Next i made a halium.config file as prompted.&lt;/p&gt;
&lt;p&gt;Next, i had to fill in the deviceinfo file. For this purpose, I used the &lt;a href=&#34;https://gitlab.com/ubports/porting/community-ports/android11/xiaomi-poco-x3-pro/xiaomi-vayu&#34;&gt;Poco X3 Pro device branch&lt;/a&gt; as a dummy template and started filling stuff according to it and the guide.&lt;/p&gt;
&lt;p&gt;But I got stuck on the &lt;em&gt;deviceinfo_bootimg_prebuilt_dtb&lt;/em&gt; step as i was not sure where to find my dtb. So i asked this question in the telegram group of Ubports and was recommended to run a script on the &lt;a href=&#34;/bootimageextractionguide/index.html&#34;&gt;boot.img which i had extracted&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The script was by LOS. It can be found &lt;a href=&#34;https://raw.githubusercontent.com/LineageOS/android_system_tools_mkbootimg/lineage-18.1/unpack_bootimg.py&#34;&gt;here&lt;/a&gt; [use it through curl -O options]. And it worked! I was able to get the output from my boot.img using the script by running this command : &lt;strong&gt;&lt;code&gt;python unpack_bootimg.py --boot_img boot.img&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;the-scripts-output-in-normal-format&#34;&gt;&lt;strong&gt;The script&amp;rsquo;s output in normal format.&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/img/pyScriptLOS18.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;But then, i was recommended to add the option &lt;strong&gt;&lt;code&gt;--format mkbootimg&lt;/code&gt;&lt;/strong&gt; along with the above command to get the outputed text in terms of mkbootimg arguments, as it would output the values that were expected for the &lt;strong&gt;deviceinfo&lt;/strong&gt; file.&lt;/p&gt;
&lt;p&gt;Unfortunately for me though, adding that option to the command gave me an error : &lt;strong&gt;&lt;code&gt;error: unrecognized arguments: --format mkbootimg&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I then thought and checked the latest LOS branch from where i had got that previous script. And i did find an updated script from LOS21 that did have those options that i needed for mkbootimg format. The new script can be found &lt;a href=&#34;https://raw.githubusercontent.com/LineageOS/android_system_tools_mkbootimg/lineage-21.0/unpack_bootimg.py&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;After this, i ran the command again, now with the additional parameters to it and was indeed able to generate the output in mkbootimg format without any errors! The updated command : &lt;strong&gt;&lt;code&gt;python unpack_bootimg.py --boot_img boot.img --format mkbootimg&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;the-scripts-output-in-mkbootimg-format&#34;&gt;&lt;strong&gt;The script&amp;rsquo;s output in mkbootimg format.&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;/img/pyScriptLOS21.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;This has given me alot to work with now. I will be looking forward to progress even further and complete the deviceinfo file.&lt;/p&gt;
</description>
	</item>
	
	<item>
		<title>Boot Image Extraction Guide</title>
		<link>/blog/bootimageextractionguide/</link>
		<pubDate>Wed, 24 Apr 2024 21:53:31 +0530</pubDate>
		
		<guid>/blog/bootimageextractionguide/</guid>
		<description>&lt;p&gt;Guide on how to extract a boot image from any Android phone [Requires Magisk and Computer]&lt;/p&gt;
&lt;h2 id=&#34;getting-started&#34;&gt;Getting started!&lt;/h2&gt;
&lt;p&gt;Accessing and modifying system files on your device typically requires superuser permissions. To extract the boot image, we&amp;rsquo;ll need a root environment. We&amp;rsquo;ll achieve this by using Magisk.&lt;/p&gt;
&lt;h4 id=&#34;manual-process&#34;&gt;Manual Process&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;First, make sure you install TWRP and then flash Magisk through it.&lt;/li&gt;
&lt;li&gt;Setup Magisk in your phone.&lt;/li&gt;
&lt;li&gt;Connect your phone to your Computer and type adb shell [Ensure that you have adb setup properly].&lt;/li&gt;
&lt;li&gt;Now, become root by typing &lt;strong&gt;su&lt;/strong&gt; in the shell on your PC.&lt;/li&gt;
&lt;li&gt;Copy/Paste the following code in the shell.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; PARTITION in &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;boot&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;boot_a&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;boot_b&amp;#34;&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt;
  BLOCK&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;find /dev/block &lt;span style=&#34;color:#ae81ff&#34;&gt;\(&lt;/span&gt; -type b -o -type c -o -type l &lt;span style=&#34;color:#ae81ff&#34;&gt;\)&lt;/span&gt; -iname &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$PARTITION&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; -print -quit 2&amp;gt;/dev/null&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt; -n &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$BLOCK&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;; &lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt;
    echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$PARTITION&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;$(&lt;/span&gt;readlink -f &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;$BLOCK&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;)&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;fi&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;done&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This command will display the boot partition paths for both A/B and A-only devices.&lt;/p&gt;
&lt;h1 id=&#34;note&#34;&gt;Note!&lt;/h1&gt;
&lt;p&gt;On &lt;a href=&#34;https://source.android.com/docs/core/ota/ab&#34;&gt;A/B devices&lt;/a&gt;, the loop command will display the boot partition paths for both slots, something like this!&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;boot_a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; /dev/block/sda40
boot_b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; /dev/block/sda41
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this case, you can extract the image corresponding to your currently active slot.To determine the active slot, enter the command &lt;code&gt;getprop ro.boot.slot_suffix&lt;/code&gt;. If the output is _a, use the path for boot_a; otherwise, use the path for boot_b.&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;Finally, use the following command to extract the image from the specified boot path:&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;dd &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&amp;lt;boot_partition_path&amp;gt; of&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&amp;lt;output_path&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;dd &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/dev/block/mmcblk0p42 of&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;/sdcard/boot_a.img
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I hope this did work for you, as it did indeed work for me!&lt;/p&gt;
&lt;p&gt;CREDITS : &lt;a href=&#34;https://gist.github.com/gitclone-url/a1f693b64d8f8701ec24477a2ccaab87&#34;&gt;Here&lt;/a&gt;&lt;/p&gt;
</description>
	</item>
	
	</channel>
</rss>
